Iterator

需求:判断集合中是否包含元素java,如果有则添加元素android
Exception in thread "main" java.util.ConcurrentModificationException：并发修改异常
迭代器Iterator接口是依赖于集合的，相当于集合的一个副本， 当迭代器在进行next()等操作的时候，如果发现和集合不一样，则抛出异常。
解决方案：
你就别使用迭代器，在使用迭代器进行遍历的时候使用别的迭代器（例如ListIterator）来进行修改。



Iterator与Iterable的区别？

 1.`Iterator`接口的核心方法next()或者hashNext()等，都是严重依赖于指针的，也就是迭代的目前的位置。如果Collection直接实现`Iterator`接口，那么集合对象就拥有了指针的能力，内部不同方法传递，就会让next()方法互相受到阻挠。只有一个迭代位置，互相干扰。
2.`Iterable` 每次获取迭代器，就会返回一个从头开始的，不会和其他的迭代器相互影响。 `iterable`接口主要是为了获取`iterator`，附带了一个`foreach()`方法。
集合`Collection`、`List`、`Set`都是Iterable的实现类，它们及其他们的子类都可以使用foreach进行迭代。 
3.这样子也是解耦合的一种，有些集合不止有一个`Iterator`内部类，可能有两个，比如`ArrayList`，`LinkedList`，可以获取不同的`Iterator`执行不一样的操作。



foreach

增强for循环，一般用于遍历集合或者数组
格式:
for(元素的类型变量:集合或省数组对象) {
		可以直接使用变量;
}
注意：在增强for循环中不能修改集合，否则会出现并发修改异常。

数组的特点：（查找快、增删慢）
数组的长度一旦定义 则不可改变
数组中的元素都有整数索引
数组只能存储同一类型的元素
数组即可以存储基本数据类型,也可以存储引用数据类型

链表：（增删快、查找慢）

List有索引，Set无索引

List集合的特点：允许重复、有索引


Set集合的特点：
无序(存储和读取的顺序有可能不一样)
不允许重复(要求元素唯一)
没有索引

使用HashSet存储自定义对象并遍历
通过查看源码发现:
HashSet的add( )方法，首先会使用当前集合中的每一个元素和新添加的元素进行hash值比较，
如果hash值不一样，则直接添加新的元素	
如果hash值一样，比较地址值或者使用equals方法进行比较
比较结果一样，则认为是重复不添加
所有的比较结果都不一样则添加。

